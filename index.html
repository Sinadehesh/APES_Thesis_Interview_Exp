<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interview Experience Research - University of Milano-Bicocca</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      padding: 20px;
    }

    .container {
      width: 100%;
      max-width: 700px;
      padding: 40px;
      background: white;
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.3);
      animation: fadeIn 0.5s ease-out;
    }

    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(20px); }
      to { opacity: 1; transform: translateY(0); }
    }

    .hidden {
      display: none !important;
    }

    h1, h2 {
      color: #2c3e50;
      margin-bottom: 20px;
      text-align: center;
    }

    h1 {
      font-size: 2em;
      border-bottom: 3px solid #667eea;
      padding-bottom: 10px;
    }

    h2 {
      font-size: 1.5em;
      color: #34495e;
    }

    h3 {
      font-size: 1.2em;
      color: #34495e;
      margin: 20px 0 15px 0;
    }

    p {
      color: #555;
      line-height: 1.6;
      margin-bottom: 15px;
      text-align: justify;
    }

    .info-box {
      background: #f8f9fa;
      border-left: 4px solid #667eea;
      padding: 20px;
      margin: 20px 0;
      border-radius: 8px;
    }

    .consent-text {
      max-height: 400px;
      overflow-y: auto;
      padding: 20px;
      background: #f8f9fa;
      border: 1px solid #dee2e6;
      border-radius: 8px;
      margin: 20px 0;
      font-size: 0.95em;
    }

    .consent-checkbox {
      display: flex;
      align-items: flex-start;
      margin: 20px 0;
      padding: 15px;
      background: #e8f4f8;
      border-radius: 8px;
      cursor: pointer;
    }

    .consent-checkbox input[type="checkbox"] {
      margin-right: 10px;
      margin-top: 3px;
      transform: scale(1.2);
      cursor: pointer;
    }

    .consent-checkbox label {
      cursor: pointer;
      flex: 1;
    }

    button {
      width: 100%;
      padding: 14px 24px;
      margin: 10px 0;
      font-size: 1.1em;
      font-weight: 600;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .btn-primary {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
    }

    .btn-primary:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
    }

    .btn-primary:disabled {
      background: #ccc;
      cursor: not-allowed;
      opacity: 0.6;
    }

    .btn-secondary {
      background: #6c757d;
      color: white;
    }

    .btn-secondary:hover {
      background: #5a6268;
    }

    .btn-record {
      background: linear-gradient(135deg, #f44336 0%, #d32f2f 100%);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .btn-record:hover:not(:disabled) {
      transform: translateY(-2px);
      box-shadow: 0 5px 20px rgba(244, 67, 54, 0.4);
    }

    .button-row {
      display: flex;
      gap: 15px;
      margin-top: 20px;
    }

    .button-row button {
      flex: 1;
    }

    .video-container {
      position: relative;
      width: 100%;
      max-width: 100%;
      margin: 20px 0;
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 0 10px 30px rgba(0,0,0,0.2);
      background: #000;
    }

    video, .video-container img {
      width: 100%;
      height: auto;
      display: block;
      border-radius: 12px;
    }

    .question-text {
      font-size: 1.3em;
      color: #2c3e50;
      text-align: center;
      margin: 20px 0;
      padding: 20px;
      background: #f8f9fa;
      border-radius: 12px;
      font-weight: 500;
    }

    .status-bar {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 15px 20px;
      background: #f8f9fa;
      border-radius: 8px;
      margin: 20px 0;
    }

    .recording-indicator {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .record-dot {
      width: 16px;
      height: 16px;
      background: #d32f2f;
      border-radius: 50%;
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.7; transform: scale(1.1); }
      100% { opacity: 1; transform: scale(1); }
    }

    .timer {
      font-size: 1.5em;
      font-weight: bold;
      color: #d32f2f;
      font-family: 'Courier New', monospace;
    }

    .redo-counter {
      color: #6c757d;
      font-weight: 500;
    }

    /* Survey Styles */
    .survey-question {
      font-size: 1.1em;
      color: #2c3e50;
      margin: 25px 0;
      line-height: 1.5;
      text-align: center;
    }

    .likert-scale {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin: 25px 0;
    }

    .likert-option {
      display: flex;
      align-items: center;
      padding: 15px 20px;
      background: #f8f9fa;
      border: 2px solid transparent;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .likert-option:hover {
      background: #e9ecef;
      border-color: #667eea;
      transform: translateX(5px);
    }

    .likert-option input[type="radio"] {
      margin-right: 15px;
      transform: scale(1.3);
      cursor: pointer;
    }

    .likert-option.selected {
      background: linear-gradient(135deg, rgba(102,126,234,0.1) 0%, rgba(118,75,162,0.1) 100%);
      border-color: #667eea;
    }

    .progress-bar {
      width: 100%;
      height: 8px;
      background: #e9ecef;
      border-radius: 4px;
      margin: 20px 0;
      overflow: hidden;
    }

    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
      border-radius: 4px;
      transition: width 0.5s ease;
    }

    .instruction-text {
      background: #fff3cd;
      border-left: 4px solid #ffc107;
      padding: 15px;
      margin: 20px 0;
      border-radius: 8px;
      color: #856404;
    }

    .calibration-check {
      display: flex;
      align-items: center;
      margin: 15px 0;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 8px;
    }

    .calibration-check input[type="checkbox"] {
      margin-right: 15px;
      transform: scale(1.3);
    }

    .error-message {
      background: #f8d7da;
      border: 1px solid #f5c6cb;
      color: #721c24;
      padding: 15px;
      border-radius: 8px;
      margin: 15px 0;
      display: none;
    }

    .block-label {
      display: inline-block;
      background: #667eea;
      color: white;
      padding: 5px 15px;
      border-radius: 20px;
      font-size: 0.9em;
      font-weight: 600;
      margin-bottom: 15px;
    }

    @media (max-width: 768px) {
      .container {
        padding: 25px;
      }
      
      h1 { font-size: 1.6em; }
      h2 { font-size: 1.3em; }
      
      .question-text {
        font-size: 1.1em;
      }
      
      .button-row {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>

<div id="consentPage" class="container">
  <h1>Research Study Consent</h1>
  <div class="info-box">
    <h3>Study Information</h3>
    <p><strong>Title:</strong> Emotional Effects of Visual Feedback in Online Automated Interviews</p>
    <p><strong>Researcher:</strong> Department of Psychology, University of Milano-Bicocca</p>
    <p><strong>Supervisor:</strong> Prof. Rossana Actis-Grosso</p>
    <p><strong>Contact:</strong> s.dehesh@campus.unimib.it</p>
  </div>
  
  <div class="consent-text">
    <h3>What is this study about?</h3>
    <p>This research investigates how different visual feedback formats in automated online interviews affect the interview experience. You will complete three short interview sessions with different visual setups.</p>
    
    <h3>What will I be asked to do?</h3>
    <p>You will answer 6 interview questions (2 per condition) while being recorded. Each response is limited to 30 seconds. After each pair of questions, you'll complete a brief survey about your experience. The entire study takes approximately 20-30 minutes.</p>
    
    <h3>Privacy and Data Protection</h3>
    <p><strong>Important:</strong> No video or audio recordings will be saved. The recording functionality is only used to simulate a real interview experience. Only your survey responses will be collected for analysis, and these will be completely anonymous.</p>
    
    <h3>Requirements</h3>
    <p>You need a computer with a working webcam and microphone, and a stable internet connection. Please ensure you're in a quiet environment where you won't be interrupted.</p>
    
    <h3>Voluntary Participation</h3>
    <p>Your participation is entirely voluntary. You may withdraw from the study at any time without penalty by closing your browser.</p>
    
    <h3>Contact Information</h3>
    <p>If you have any questions about this research, please contact: <strong>s.dehesh@campus.unimib.it</strong></p>
    <p>Department of Psychology, University of Milano-Bicocca</p>
  </div>
  
  <div class="consent-checkbox">
    <input type="checkbox" id="consentCheck">
    <label for="consentCheck">
      <strong>I have read and understood the information above. I agree to participate in this study and allow access to my camera and microphone (for simulation only - no recordings will be saved).</strong>
    </label>
  </div>
  
  <p style="text-align: center; margin-top: 20px; color: #6c757d;">
    <strong>Before you begin:</strong> If you have any questions, please email <strong>s.dehesh@campus.unimib.it</strong>
  </p>
  
  <button id="consentBtn" class="btn-primary" disabled>Continue to Study</button>
</div>

<div id="calibrationPage" class="container hidden">
  <h1>System Check</h1>
  <div class="block-label">Calibration</div>
  
  <div class="instruction-text">
    <strong>Let's make sure everything is working properly.</strong><br>
    We'll test your camera and microphone. Remember, no recordings are being saved.<br>
    If you experience any problems, please contact: <strong>s.dehesh@campus.unimib.it</strong>
  </div>
  
  <div id="calibrationStep1">
    <h3>Camera & Microphone Test</h3>
    <p>Click the button below to record yourself counting "1, 2, 3" while looking at the camera:</p>
    <div class="video-container">
      <video id="calibrationVideo" autoplay muted playsinline></video>
    </div>
    <button id="startCalibrationBtn" class="btn-record">
      <span id="calibrationBtnText">Start Test Recording</span>
    </button>
    <div class="status-bar" id="calibrationStatus" style="display: none;">
      <div class="recording-indicator">
        <div class="record-dot"></div>
        <span style="color: #d32f2f;">Recording Test</span>
      </div>
      <div class="timer" id="calibrationTimer">0:03</div>
    </div>
  </div>
  
  <div id="calibrationStep2" class="hidden">
    <h3>Review Your Test Recording</h3>
    <p>Please watch your test recording and confirm you can see and hear yourself:</p>
    <div class="video-container">
      <video id="calibrationPlayback" controls></video>
    </div>
    
    <div class="calibration-check">
      <input type="checkbox" id="seeCheck">
      <label for="seeCheck"><strong>Did you see yourself?</strong> Yes, I could see myself clearly</label>
    </div>
    
    <div class="calibration-check">
      <input type="checkbox" id="hearCheck">
      <label for="hearCheck"><strong>Could you hear yourself?</strong> Yes, I could hear my voice clearly</label>
    </div>
    
    <button id="retryCalibrationBtn" class="btn-secondary">Retry Test</button>
    
    <p style="text-align: center; margin-top: 15px; color: #6c757d; font-size: 0.9em;">
      Can't see or hear yourself? Check your volume and try again.<br>
      Still having issues? Contact: <strong>s.dehesh@campus.unimib.it</strong>
    </p>
  </div>
  
  <div class="error-message" id="calibrationError">
    If you cannot see or hear yourself properly, please check your browser permissions and try again. 
    For assistance, contact: <strong>s.dehesh@campus.unimib.it</strong>
  </div>
  
  <button id="calibrationContinueBtn" class="btn-primary" disabled>Continue to Instructions</button>
</div>

<div id="instructionsPage" class="container hidden">
  <h1>Interview Instructions</h1>
  
  <div class="info-box">
    <h3>What to Expect</h3>
    <p>You'll complete <strong>3 different interview formats</strong>, each with <strong>2 questions</strong>:</p>
    <ul style="margin-left: 20px; margin-top: 10px;">
      <li>Format 1: You'll see yourself on screen (like a video call)</li>
      <li>Format 2: You'll see an animated avatar that asks the questions</li>
      <li>Format 3: You'll see only the question text</li>
    </ul>
  </div>
  
  <h3>For Each Question:</h3>
  <ol style="margin-left: 20px; line-height: 1.8;">
    <li>Read/watch the question carefully</li>
    <li>Click "Start Recording" when ready</li>
    <li>You have <strong>30 seconds</strong> to answer</li>
    <li>You can "Redo" if you want to try again</li>
    <li>Review your recording and click "Next"</li>
  </ol>
  
  <p style="text-align: center; margin-top: 20px; color: #6c757d;">
    <strong>Need help?</strong> Contact: s.dehesh@campus.unimib.it
  </p>
  
  <button id="startExperimentBtn" class="btn-primary">Begin Interview</button>
</div>

<div id="interviewPage" class="container hidden">
  <div class="block-label" id="conditionLabel">Condition 1 of 3</div>
  
  <div class="question-text" id="questionText"></div>
  
  <div id="viewContainer" class="video-container"></div>
  
  <p id="recordInstruction" style="text-align: center; color: #6c757d; margin: 15px 0;">
    Click <strong>Start Recording</strong> when you're ready. You'll have 30 seconds.
  </p>
  
  <button id="startRecordingBtn" class="btn-record">Start Recording</button>
  
  <div class="status-bar" id="statusBar" style="display: none;">
    <div class="redo-counter" id="redoCount">Attempts: 1</div>
    <div class="recording-indicator">
      <div class="record-dot" id="recordIndicator" style="display: none;"></div>
      <span style="color: #d32f2f;">Recording</span>
    </div>
    <div class="timer" id="timerDisplay">0:30</div>
  </div>
  
  <div class="button-row" id="recordingControls" style="display: none;">
    <button id="redoBtn" class="btn-secondary">Redo</button>
    <button id="stopBtn" class="btn-primary">Stop Recording</button>
  </div>
</div>

<div id="previewPage" class="container hidden">
  <h2>Review Your Response</h2>
  <p style="text-align: center; color: #6c757d;">Watch your recording. If you're satisfied, click Next. Otherwise, click Redo.</p>
  
  <div class="video-container">
    <video id="previewVideo" controls></video>
  </div>
  
  <div class="button-row">
    <button id="previewRedoBtn" class="btn-secondary">Redo This Question</button>
    <button id="previewNextBtn" class="btn-primary">Next</button>
  </div>
</div>

<div id="surveyPage" class="container hidden">
  <h2 id="surveyTitle">Post-Interview Questions</h2>
  <div class="block-label" id="surveyConditionLabel">After Condition 1</div>
  
  <div class="progress-bar">
    <div class="progress-fill" id="surveyProgress"></div>
  </div>
  
  <div class="survey-question" id="surveyQuestion"></div>
  
  <div class="likert-scale" id="likertOptions"></div>
  
  <button id="surveySubmitBtn" class="btn-primary" disabled>Next Question</button>
  
  <p style="text-align: center; color: #6c757d; margin-top: 20px;">
    Question <span id="surveyQuestionNumber">1</span> of 3
  </p>
</div>

<div id="debriefPage" class="container hidden">
  <h1>Study Complete!</h1>
  
  <div class="info-box">
    <h3>Thank you for participating!</h3>
    <p>Your contribution helps us understand how visual feedback affects interview experiences.</p>
  </div>
  
  <h3>Study Purpose</h3>
  <p>This research examines whether seeing yourself during video interviews (self-referential information) affects anxiety levels and self-expression compared to alternative formats like avatars or text-only interfaces.</p>
  
  <h3>What We Measured</h3>
  <p>We collected your ratings of anxiety, expressiveness, and perceived judgment across the three different interview formats. This will help us identify which formats create the best interview experience.</p>
  
  <h3>Your Privacy</h3>
  <p><strong>Reminder:</strong> No video or audio recordings were saved. Only your survey responses were collected, and these are completely anonymous.</p>
  
  <h3>Questions?</h3>
  <p>If you have any questions about this research or encountered any technical difficulties, please contact:</p>
  <p style="text-align: center; font-size: 1.1em;"><strong>s.dehesh@campus.unimib.it</strong></p>
  <p style="text-align: center;">Department of Psychology, University of Milano-Bicocca</p>
  
  <div style="text-align: center; margin-top: 30px;">
    <p style="font-size: 1.2em; color: #667eea; font-weight: 600;">
      We wish you the best of luck in your future endeavors!
    </p>
  </div>
</div>

<script>
// Configuration
const CONFIG = {
  questions: [
    "Tell me about yourself.",
    "What are your strengths?",
    "How do you prioritize your work?",
    "How do you stay organized?",
    "Describe a time you overcame a challenge.",
    "Where do you see yourself in five years?"
  ],
  
  conditions: [1, 1, 2, 2, 3, 3], // 1=SRI, 2=Avatar, 3=Text
  avatarVideos: ["0729-1.mp4", "0729-2.mp4"],
  avatarImage: "input.jpg",
  
  surveyQuestions: [
    {
      id: "anxiety",
      text: "While answering these two questions <strong>I felt anxious</strong> during this interview.",
      scale: ["Not at all", "Slightly", "Moderately", "Very", "Extremely"]
    },
    {
      id: "expression",
      text: "While answering these two questions <strong>I was able to express myself clearly</strong>.",
      scale: ["Not at all", "Slightly", "Moderately", "Very", "Extremely"]
    },
    {
      id: "judgment",
      text: "While answering these two questions <strong>I felt I would be judged more negatively</strong>.",
      scale: ["Not at all", "Slightly", "Moderately", "Very", "Extremely"]
    }
  ],
  
  orders: {
    A: [0,1,2,3,4,5],
    B: [0,1,4,5,2,3],
    C: [2,3,0,1,4,5],
    D: [2,3,4,5,0,1],
    E: [4,5,0,1,2,3],
    F: [4,5,2,3,0,1]
  }
};

// State Management
let state = {
  participantId: null,
  orderGroup: null,
  questionOrder: [],
  currentQuestionIndex: 0,
  currentCondition: 0,
  redoCounts: Array(6).fill(0),
  responses: {},
  stream: null,
  mediaRecorder: null,
  recordedChunks: [],
  countdownInterval: null,
  currentSurveyQuestion: 0,
  completedConditions: 0
};

// DOM Elements
const pages = {
  consent: document.getElementById('consentPage'),
  calibration: document.getElementById('calibrationPage'),
  instructions: document.getElementById('instructionsPage'),
  interview: document.getElementById('interviewPage'),
  preview: document.getElementById('previewPage'),
  survey: document.getElementById('surveyPage'),
  debrief: document.getElementById('debriefPage')
};

// Utility Functions
function showPage(pageName) {
  Object.values(pages).forEach(page => {
    if (page) page.classList.add('hidden'); // Add check if page exists
  });
  if (pages[pageName]) { // Add check if target page exists
    pages[pageName].classList.remove('hidden');
  } else {
    console.error("Attempted to show non-existent page:", pageName);
  }
}


function generateParticipantId() {
  return 'P' + Date.now() + Math.random().toString(36).substr(2, 5);
}

function assignOrderGroup() {
  const groups = Object.keys(CONFIG.orders); // Use keys from CONFIG
  return groups[Math.floor(Math.random() * groups.length)];
}

// Initialize Media
async function initializeMedia() {
  try {
    state.stream = await navigator.mediaDevices.getUserMedia({ 
      video: true, 
      audio: true 
    });
    
    const calibrationVideo = document.getElementById('calibrationVideo');
    if (calibrationVideo) {
      calibrationVideo.srcObject = state.stream;
    } else {
      console.error("Calibration video element not found");
    }
  } catch (error) {
    console.error("Error getting user media:", error);
    const errorDiv = document.getElementById('calibrationError');
    if (errorDiv) {
      errorDiv.style.display = 'block';
      errorDiv.innerHTML = 
        '<strong>Camera/microphone access denied or unavailable.</strong><br>' +
        'Please allow access in your browser settings and reload the page.<br>' +
        'Ensure no other application is using the camera/mic.<br>' +
        'If problems persist, contact: <strong>s.dehesh@campus.unimib.it</strong>';
    }
    const startCalibBtn = document.getElementById('startCalibrationBtn');
    if (startCalibBtn) {
      startCalibBtn.disabled = true;
    }
  }
}

// Wait for DOM to be fully loaded
document.addEventListener('DOMContentLoaded', function() {
  // Consent Page
  const consentCheck = document.getElementById('consentCheck');
  const consentBtn = document.getElementById('consentBtn');
  
  if (consentCheck && consentBtn) {
    consentCheck.addEventListener('change', (e) => {
      consentBtn.disabled = !e.target.checked;
    });
    
    consentBtn.addEventListener('click', async () => {
      // Disable button immediately to prevent double clicks
      consentBtn.disabled = true;
      consentBtn.textContent = "Loading...";

      state.participantId = generateParticipantId();
      state.orderGroup = assignOrderGroup();
      if (!CONFIG.orders[state.orderGroup]) {
          console.error("Invalid order group assigned:", state.orderGroup);
          // Fallback to a default order if needed
          state.orderGroup = 'A';
      }
      state.questionOrder = CONFIG.orders[state.orderGroup];
      
      showPage('calibration');
      await initializeMedia(); // Wait for media before proceeding implicitly

      // Re-enable button potentially in initializeMedia's success/error handling
      // For simplicity, we'll assume it initializes quickly or handles errors itself
      // If initializeMedia failed, the calibration start button will be disabled anyway.
      // If successful, the user interacts with calibration page next.
    });
  } else {
    console.error("Consent elements not found");
  }

  // Calibration Page
  let calibrationRecorder = null;
  let calibrationChunks = [];
  let calibrationCountdown = null;

  const startCalibrationBtn = document.getElementById('startCalibrationBtn');
  if (startCalibrationBtn) {
    startCalibrationBtn.addEventListener('click', startCalibrationRecording);
  } else {
    console.error("Start calibration button not found");
  }


  function startCalibrationRecording() {
    if (!state.stream) {
      alert('Camera not initialized. Please allow camera access and reload.');
      return;
    }
    
    calibrationChunks = [];
    try {
      // Check if MediaRecorder is available
      if (typeof MediaRecorder === 'undefined') {
          alert('MediaRecorder API is not supported in your browser.');
          return;
      }
      calibrationRecorder = new MediaRecorder(state.stream);
    } catch (e) {
      console.error("Error creating MediaRecorder:", e);
      alert("Could not start recording. Your browser might not support this feature or there's an issue with the camera/mic stream.");
      return;
    }
    
    calibrationRecorder.ondataavailable = (event) => {
      if (event.data && event.data.size > 0) {
        calibrationChunks.push(event.data);
      }
    };
    
    calibrationRecorder.onstop = () => {
      // Ensure timer is cleared if stop happens early
      if (calibrationCountdown) clearInterval(calibrationCountdown);
      calibrationCountdown = null;
      const calibStatus = document.getElementById('calibrationStatus');
      if(calibStatus) calibStatus.style.display = 'none'; // Hide status bar

      if (calibrationChunks.length === 0) {
        console.warn("Calibration recording stopped with no data.");
        alert("Test recording failed (no data captured). Please check permissions and try again.");
        // Reset UI to try again
        const startBtn = document.getElementById('startCalibrationBtn');
        if(startBtn) startBtn.style.display = 'block';
        return; // Stop further processing
      }

      const blob = new Blob(calibrationChunks, { type: 'video/webm' });
      const url = URL.createObjectURL(blob);
      const playbackVideo = document.getElementById('calibrationPlayback');
      if (playbackVideo) {
        playbackVideo.src = url;
        playbackVideo.muted = false; // Allow playback sound
      } else {
        console.error("Playback video element not found");
      }
      
      const step1 = document.getElementById('calibrationStep1');
      if (step1) step1.classList.add('hidden');
      const step2 = document.getElementById('calibrationStep2');
      if (step2) step2.classList.remove('hidden');
    };

    calibrationRecorder.onerror = (event) => {
      console.error("MediaRecorder error:", event.error);
      alert("An error occurred during test recording: " + event.error.name);
      // Reset UI
      if (calibrationCountdown) clearInterval(calibrationCountdown);
      calibrationCountdown = null;
      const startBtn = document.getElementById('startCalibrationBtn');
      if (startBtn) startBtn.style.display = 'block';
      const calibStatus = document.getElementById('calibrationStatus');
      if (calibStatus) calibStatus.style.display = 'none';
    };
    
    const startBtn = document.getElementById('startCalibrationBtn');
    if (startBtn) startBtn.style.display = 'none'; // Hide button
    const calibStatus = document.getElementById('calibrationStatus');
    if (calibStatus) calibStatus.style.display = 'flex'; // Show status
    
    try {
      calibrationRecorder.start();
    } catch (e) {
      console.error("Error starting MediaRecorder:", e);
      alert("Could not start test recording.");
      // Reset UI
      if (startBtn) startBtn.style.display = 'block';
      if (calibStatus) calibStatus.style.display = 'none';
      return;
    }
    
    let timeLeft = 3;
    const timerDisplay = document.getElementById('calibrationTimer');
    
    if (calibrationCountdown) clearInterval(calibrationCountdown); // Clear just in case
    calibrationCountdown = setInterval(() => {
      if (timerDisplay) timerDisplay.textContent = `0:0${timeLeft}`;
      timeLeft--;
      
      if (timeLeft < 0) {
        // Interval clears itself, just need to stop recorder if it's still running
        if (calibrationRecorder && calibrationRecorder.state === 'recording') {
          try {
            calibrationRecorder.stop(); // onstop will handle UI changes
          } catch (stopError) {
             console.error("Error stopping calibration recorder:", stopError);
             // Manually trigger UI changes if stop fails? Risky.
             if (calibStatus) calibStatus.style.display = 'none';
          }
        } else {
            // If recorder already stopped (e.g., error), just ensure UI is reset
            if (calibStatus) calibStatus.style.display = 'none';
        }
      }
    }, 1000);
  }

  const retryBtn = document.getElementById('retryCalibrationBtn');
  if (retryBtn) {
    retryBtn.addEventListener('click', () => {
      const step1 = document.getElementById('calibrationStep1');
      if (step1) step1.classList.remove('hidden');
      const step2 = document.getElementById('calibrationStep2');
      if (step2) step2.classList.add('hidden');
      const startBtn = document.getElementById('startCalibrationBtn');
      if (startBtn) startBtn.style.display = 'block'; // Show start button again
      const seeChk = document.getElementById('seeCheck');
      if (seeChk) seeChk.checked = false;
      const hearChk = document.getElementById('hearCheck');
      if (hearChk) hearChk.checked = false;
      const contBtn = document.getElementById('calibrationContinueBtn');
      if (contBtn) contBtn.disabled = true;
      const calibError = document.getElementById('calibrationError');
      if (calibError) calibError.style.display = 'none';

      const video = document.getElementById('calibrationPlayback');
      if (video) {
        video.pause();
        // Revoke previous object URL to free memory
        if (video.src && video.src.startsWith('blob:')) {
            URL.revokeObjectURL(video.src);
        }
        video.removeAttribute('src'); // Clear source
        video.load(); // Reset video element state
      }
      // Reset recorder state variables
      calibrationChunks = [];
      calibrationRecorder = null;
      if (calibrationCountdown) {
          clearInterval(calibrationCountdown);
          calibrationCountdown = null;
      }
      const calibStatus = document.getElementById('calibrationStatus');
      if (calibStatus) calibStatus.style.display = 'none'; // Ensure status bar is hidden
    });
  } else {
    console.error("Retry calibration button not found");
  }


  const seeCheck = document.getElementById('seeCheck');
  const hearCheck = document.getElementById('hearCheck');
  if (seeCheck) {
      seeCheck.addEventListener('change', checkCalibrationComplete);
  } else {
      console.error("See checkbox not found");
  }
  if (hearCheck) {
      hearCheck.addEventListener('change', checkCalibrationComplete);
  } else {
      console.error("Hear checkbox not found");
  }

  function checkCalibrationComplete() {
    // Ensure elements are checked for existence inside the function too
    const canSee = seeCheck ? seeCheck.checked : false;
    const canHear = hearCheck ? hearCheck.checked : false;
    const contBtn = document.getElementById('calibrationContinueBtn');
    const errorMsg = document.getElementById('calibrationError');
    const step2 = document.getElementById('calibrationStep2');
    
    if (canSee && canHear) {
      if (contBtn) contBtn.disabled = false;
      if (errorMsg) errorMsg.style.display = 'none';
    } else {
      if (contBtn) contBtn.disabled = true;
      // Only show error message if step 2 is currently visible
      if (step2 && !step2.classList.contains('hidden')) {
        if (errorMsg) errorMsg.style.display = 'block';
      } else {
        if (errorMsg) errorMsg.style.display = 'none'; // Hide if step 2 is not visible
      }
    }
  }

  const calibContinueBtn = document.getElementById('calibrationContinueBtn');
  if (calibContinueBtn) {
    calibContinueBtn.addEventListener('click', () => {
      showPage('instructions');
    });
  } else {
    console.error("Calibration continue button not found");
  }


  // Instructions Page
  const startExperimentBtn = document.getElementById('startExperimentBtn');
   if (startExperimentBtn) {
    startExperimentBtn.addEventListener('click', () => {
      showPage('interview');
      showQuestion(); // Call showQuestion here to display the first question
    });
  } else {
    console.error("Start experiment button not found");
  }


  // Interview Page Event Listeners (ensure elements exist before adding listeners)
  const startRecordingBtn = document.getElementById('startRecordingBtn');
  if (startRecordingBtn) startRecordingBtn.addEventListener('click', startRecording);
  else console.error("Start recording button not found");

  const stopBtn = document.getElementById('stopBtn');
  if (stopBtn) stopBtn.addEventListener('click', stopRecording);
  else console.error("Stop button not found");

  const redoBtn = document.getElementById('redoBtn');
  if (redoBtn) redoBtn.addEventListener('click', redoRecording);
  else console.error("Redo button not found");

  const previewRedoBtn = document.getElementById('previewRedoBtn');
  if (previewRedoBtn) previewRedoBtn.addEventListener('click', redoRecording);
  else console.error("Preview redo button not found");

  const previewNextBtn = document.getElementById('previewNextBtn');
  if (previewNextBtn) previewNextBtn.addEventListener('click', previewNext);
  else console.error("Preview next button not found");

  const surveySubmitBtn = document.getElementById('surveySubmitBtn');
  if (surveySubmitBtn) surveySubmitBtn.addEventListener('click', surveySubmit);
  else console.error("Survey submit button not found");

}); // End DOMContentLoaded

// Interview Functions
function showQuestion() {
  // Defensive check for question order
  if (!state.questionOrder || state.questionOrder.length === 0) {
      console.error("Question order is not set.");
      showPage('debrief'); // Go to end state if order is missing
      return;
  }
  const questionIdx = state.questionOrder[state.currentQuestionIndex];
  // Defensive check for valid index
  if (questionIdx === undefined || questionIdx >= CONFIG.questions.length) {
    console.error("Invalid question index derived:", questionIdx, "from index", state.currentQuestionIndex, "in order", state.questionOrder);
    showPage('debrief'); // Go to end state
    return;
  }
  const condition = CONFIG.conditions[questionIdx];
  const conditionNum = Math.floor(state.currentQuestionIndex / 2) + 1;
  
  const condLabel = document.getElementById('conditionLabel');
  if (condLabel) condLabel.textContent = `Condition ${conditionNum} of 3`;
  
  const recInstruction = document.getElementById('recordInstruction');
  if (recInstruction) recInstruction.style.display = 'block';
  const startRecBtn = document.getElementById('startRecordingBtn');
  if (startRecBtn) startRecBtn.style.display = 'block';
  const statusBar = document.getElementById('statusBar');
  if (statusBar) statusBar.style.display = 'none';
  const recControls = document.getElementById('recordingControls');
  if (recControls) recControls.style.display = 'none';
  const redoCountEl = document.getElementById('redoCount');
  if (redoCountEl) redoCountEl.textContent = `Attempts: ${state.redoCounts[questionIdx] + 1}`;
  
  const viewContainer = document.getElementById('viewContainer');
  const questionTextEl = document.getElementById('questionText');

  if (!viewContainer || !questionTextEl) {
    console.error("showQuestion: viewContainer or questionText element not found");
    return;
  }
  
  viewContainer.innerHTML = ''; // Clear previous content
  viewContainer.style.display = 'block'; // Ensure it's visible by default
  questionTextEl.textContent = ''; // Clear previous text
  
  if (condition === 1) { // SRI
    questionTextEl.textContent = CONFIG.questions[questionIdx];
    if (state.stream) {
      const video = document.createElement('video');
      video.srcObject = state.stream;
      video.autoplay = true;
      video.muted = true;
      video.playsinline = true; // Good for mobile
      viewContainer.appendChild(video);
    } else {
      console.error("Stream not available for SRI condition");
      questionTextEl.textContent = CONFIG.questions[questionIdx] + " (Camera feed unavailable)";
    }
  } else if (condition === 2) { // Avatar
    // Calculate index relative to the start of condition 2 questions in the base list
    const avatarBaseIndex = CONFIG.conditions.indexOf(2); // Find first index of condition 2 (should be 2)
    if (avatarBaseIndex === -1) {
        console.error("Condition 2 (Avatar) not found in CONFIG.conditions");
        questionTextEl.textContent = "Error: Avatar configuration missing.";
        return;
    }
    const avatarIdx = questionIdx - avatarBaseIndex;

    if (avatarIdx >= 0 && avatarIdx < CONFIG.avatarVideos.length) {
      const video = document.createElement('video');
      video.src = CONFIG.avatarVideos[avatarIdx];
      video.controls = true; // Let user control playback if needed
      video.autoplay = true;
      video.playsinline = true;
      // Add event listener for when video ends, maybe enable record button then?
      // video.onended = () => { /* Enable record button */ };
      viewContainer.appendChild(video);
      questionTextEl.textContent = ''; // Question is in the video
    } else {
      console.error("Invalid avatar index calculated:", avatarIdx, "for question index", questionIdx);
      questionTextEl.textContent = "Error: Could not load question video."; // Fallback text
    }
  } else if (condition === 3) { // Text-only
    questionTextEl.textContent = CONFIG.questions[questionIdx];
    viewContainer.style.display = 'none'; // Hide the video container
  } else {
    console.error("Unknown condition type in showQuestion:", condition);
    questionTextEl.textContent = "Error: Unknown question format.";
  }
}


function startRecording() {
  if (!state.stream) {
    alert('Camera not initialized. Please reload the page.');
    return;
  }
  
  const questionIdx = state.questionOrder[state.currentQuestionIndex];
  if (questionIdx === undefined) {
      console.error("startRecording: Invalid question index");
      return;
  }
  const condition = CONFIG.conditions[questionIdx];
  
  // Update UI elements safely
  const recInstruction = document.getElementById('recordInstruction');
  if (recInstruction) recInstruction.style.display = 'none';
  const startRecBtn = document.getElementById('startRecordingBtn');
  if (startRecBtn) startRecBtn.style.display = 'none';
  const statusBar = document.getElementById('statusBar');
  if (statusBar) statusBar.style.display = 'flex';
  const recControls = document.getElementById('recordingControls');
  if (recControls) recControls.style.display = 'flex';
  const recIndicator = document.getElementById('recordIndicator');
  if (recIndicator) recIndicator.style.display = 'block';
  
  if (condition === 2) { // Switch avatar video to static image during recording
    const viewContainer = document.getElementById('viewContainer');
    if (viewContainer) {
      viewContainer.style.display = 'block'; // Ensure visible
      viewContainer.innerHTML = ''; // Clear video
      const img = document.createElement('img');
      img.src = CONFIG.avatarImage;
      img.alt = 'Avatar';
      viewContainer.appendChild(img);
    }
  }
  
  state.recordedChunks = [];
  try {
    if (typeof MediaRecorder === 'undefined') {
        throw new Error('MediaRecorder API not supported');
    }
    state.mediaRecorder = new MediaRecorder(state.stream);
  } catch (e) {
      console.error("Error creating MediaRecorder:", e);
      alert("Could not start recording. Please check browser permissions and support.");
      // Attempt to reset UI back to pre-recording state
      if (recInstruction) recInstruction.style.display = 'block';
      if (startRecBtn) startRecBtn.style.display = 'block';
      if (statusBar) statusBar.style.display = 'none';
      if (recControls) recControls.style.display = 'none';
      if (recIndicator) recIndicator.style.display = 'none';
      return;
  }

  state.mediaRecorder.ondataavailable = (event) => {
    if (event.data && event.data.size > 0) {
      state.recordedChunks.push(event.data);
    }
  };
  
  state.mediaRecorder.onstop = () => {
    // Clear timer when stopped, regardless of how it stopped
    clearInterval(state.countdownInterval);
    state.countdownInterval = null;

    if (state.recordedChunks.length === 0) {
        console.warn("Recording stopped with no data chunks. This might happen if stopped immediately or due to an error.");
        // We might want to prevent proceeding or show a message, but for now, we'll try to go to preview.
        // If the blob is empty, the preview video will show an error or be blank.
    }
    const blob = new Blob(state.recordedChunks, { type: 'video/webm' });
    const url = URL.createObjectURL(blob);
    const previewVideo = document.getElementById('previewVideo');
    if (previewVideo) {
      previewVideo.src = url;
      previewVideo.muted = false; // Allow sound on preview
    } else {
        console.error("Preview video element not found");
        URL.revokeObjectURL(url); // Clean up blob URL if element is missing
        // Handle error - maybe force redo or go to next step cautiously?
        alert("Error showing preview. Please try redoing the question.");
        redoRecording();
        return;
    }
    showPage('preview');
  };

  state.mediaRecorder.onerror = (event) => {
    console.error("MediaRecorder error during recording:", event.error);
    alert("An error occurred during recording: " + event.error.name + ". Please try again.");
    clearInterval(state.countdownInterval); // Ensure timer stops on error
    state.countdownInterval = null;
    // Attempt to reset UI and allow redo
    showPage('interview');
    showQuestion(); // Reset to current question
  };
  
  try {
    state.mediaRecorder.start();
    startTimer(); // Start timer only after successfully starting recorder
  } catch (e) {
      console.error("Error starting MediaRecorder:", e);
      alert("Could not start recording: " + e.message);
       // Reset UI back to pre-recording state
      if (recInstruction) recInstruction.style.display = 'block';
      if (startRecBtn) startRecBtn.style.display = 'block';
      if (statusBar) statusBar.style.display = 'none';
      if (recControls) recControls.style.display = 'none';
      if (recIndicator) recIndicator.style.display = 'none';
  }
}

function startTimer() {
  let timeLeft = 30;
  const timerDisplay = document.getElementById('timerDisplay');
  
  clearInterval(state.countdownInterval); // Clear any existing timer first
  state.countdownInterval = null; // Reset interval ID
  
  state.countdownInterval = setInterval(() => {
    const minutes = Math.floor(timeLeft / 60);
    const seconds = timeLeft % 60;
    if (timerDisplay) {
      // Ensure timer text updates correctly even if element was missing before
      timerDisplay.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
    }
    
    timeLeft--;
    
    if (timeLeft < 0) {
      // No need to clear interval here, stopRecording will do it.
      stopRecording(); // Call stopRecording, which clears interval and stops recorder
    }
  }, 1000);
}


function stopRecording() {
  clearInterval(state.countdownInterval);
  state.countdownInterval = null; // Ensure interval ID is cleared
  if (state.mediaRecorder && state.mediaRecorder.state === 'recording') {
    // Wrap stop() in a try-catch as it can sometimes throw errors
    try {
      state.mediaRecorder.stop();
      // Note: UI updates (like hiding status bar) are better handled in onstop
    } catch (e) {
      console.error("Error stopping MediaRecorder:", e);
      // If stop fails, attempt to manually trigger the onstop logic if chunks exist
      // This is a fallback and might not always work perfectly
      if (state.recordedChunks.length > 0) {
          console.warn("Attempting manual trigger of onstop logic due to stop() error.");
          const blob = new Blob(state.recordedChunks, { type: 'video/webm' });
          const url = URL.createObjectURL(blob);
          const previewVideo = document.getElementById('previewVideo');
          if (previewVideo) {
              previewVideo.src = url;
              previewVideo.muted = false;
              showPage('preview');
          } else {
              URL.revokeObjectURL(url); // Clean up if no preview element
              alert("Recording stopped with error, and preview failed. Please redo.");
              redoRecording();
          }
      } else {
         alert("Recording failed to stop correctly. Please try redoing the question.");
         redoRecording(); // Force redo if stop fails badly with no data
      }
    }
  } else {
    // If recorder wasn't recording but stop was called (e.g., rapid clicks), log it.
    console.warn("stopRecording called but MediaRecorder was not in 'recording' state.");
  }
}

function redoRecording() {
  const questionIdx = state.questionOrder[state.currentQuestionIndex];
  if (questionIdx === undefined) {
      console.error("redoRecording: Invalid question index");
      return; // Prevent incrementing count for invalid index
  }
  state.redoCounts[questionIdx]++;
  
  clearInterval(state.countdownInterval);
  state.countdownInterval = null;
  if (state.mediaRecorder && state.mediaRecorder.state !== 'inactive') {
    console.log("Stopping active recorder for redo...");
    // Don't call stopRecording() directly as it transitions state, just stop it
    try {
      if (state.mediaRecorder.state === 'recording') {
          state.mediaRecorder.stop(); // This should trigger onstop eventually
      }
      // If paused, just reset state
      state.mediaRecorder = null;
      state.recordedChunks = [];
    } catch (e) {
        console.error("Error stopping recorder on redo:", e);
        // Reset state anyway
        state.mediaRecorder = null;
        state.recordedChunks = [];
    }
  } else {
    // Ensure state is clean even if recorder was already inactive
    state.mediaRecorder = null;
    state.recordedChunks = [];
  }


  // Clean up preview video URL if redoing from preview page
  const previewVideo = document.getElementById('previewVideo');
  if (previewVideo && previewVideo.src && previewVideo.src.startsWith('blob:')) {
      URL.revokeObjectURL(previewVideo.src);
      previewVideo.removeAttribute('src');
      previewVideo.load();
  }
  
  showPage('interview');
  showQuestion(); // Reload the question UI
}

function previewNext() {
  const video = document.getElementById('previewVideo');
  if (video) {
    video.pause();
    // Clean up Blob URL to prevent memory leaks
    if (video.src && video.src.startsWith('blob:')) {
        URL.revokeObjectURL(video.src);
        console.log("Revoked preview URL:", video.src);
    }
    video.removeAttribute('src'); // Clear the source
    video.load(); // Reset video element
  }
  
  state.currentQuestionIndex++;
  
  // Check completion condition more carefully
  if (state.currentQuestionIndex < 6) {
    if (state.currentQuestionIndex % 2 === 0) {
        // Just finished question 1, 3, or 5 (0-indexed) -> show survey
        showSurvey();
    } else {
        // Just finished question 0, 2, or 4 -> show next interview question
        showPage('interview');
        showQuestion();
    }
  } else {
    // Index is 6 (meaning all 6 questions 0-5 are done) -> show debrief
    showPage('debrief');
    submitData();
  }
}


// Survey Functions
function showSurvey() {
  state.completedConditions++; // Increment block counter
  state.currentSurveyQuestion = 0; // Reset question index within block
  
  const conditionNum = state.completedConditions; // Use the incremented value
  
  const surveyTitle = document.getElementById('surveyTitle');
  if (surveyTitle) surveyTitle.textContent = 'Post-Interview Questions';
  const surveyCondLabel = document.getElementById('surveyConditionLabel');
  // Update label correctly based on which block this IS, not which one is next
  if (surveyCondLabel) surveyCondLabel.textContent = `After Condition ${conditionNum}`;
  
  showPage('survey');
  displaySurveyQuestion(); // Display the first question of this survey block
}

function displaySurveyQuestion() {
  // Add safety check
  if (state.currentSurveyQuestion >= CONFIG.surveyQuestions.length || state.currentSurveyQuestion < 0) {
    console.error("Invalid survey question index:", state.currentSurveyQuestion);
    // Attempt to recover: maybe move to next phase?
    if (state.currentQuestionIndex < 6) {
      showPage('interview');
      showQuestion();
    } else {
      showPage('debrief');
      submitData();
    }
    return;
  }
  const question = CONFIG.surveyQuestions[state.currentSurveyQuestion];
  
  const surveyQuestionEl = document.getElementById('surveyQuestion');
  if (surveyQuestionEl) surveyQuestionEl.innerHTML = question.text;
  const surveyQNumEl = document.getElementById('surveyQuestionNumber');
  if (surveyQNumEl) surveyQNumEl.textContent = state.currentSurveyQuestion + 1;
  
  const progress = ((state.currentSurveyQuestion + 1) / CONFIG.surveyQuestions.length) * 100;
  const surveyProgressEl = document.getElementById('surveyProgress');
  if (surveyProgressEl) surveyProgressEl.style.width = `${progress}%`;
  
  const optionsContainer = document.getElementById('likertOptions');
  if (!optionsContainer) {
    console.error("Likert options container not found");
    return; // Cannot proceed without options container
  }
  optionsContainer.innerHTML = ''; // Clear previous options
  
  // Check if scale exists
  if (!question.scale || !Array.isArray(question.scale)) {
      console.error("Survey question missing scale array:", question.id);
      optionsContainer.innerHTML = "<p>Error: Options not available.</p>";
      return;
  }

  question.scale.forEach((option, index) => {
    const div = document.createElement('div');
    div.className = 'likert-option';
    
    const input = document.createElement('input');
    input.type = 'radio';
    input.name = 'likert'; // Group radios together
    input.value = index + 1; // Store value 1-5
    input.id = `option${index}`; // Unique ID for label association
    
    const label = document.createElement('label');
    label.htmlFor = `option${index}`;
    label.textContent = option;
    label.style.flex = '1'; // Ensure label takes up space
    label.style.cursor = 'pointer'; // Indicate clickability
    
    div.appendChild(input);
    div.appendChild(label);
    
    // Add event listener to the container div for better click handling
    div.addEventListener('click', () => {
      // Ensure only one option is visually selected
      optionsContainer.querySelectorAll('.likert-option').forEach(opt => {
        opt.classList.remove('selected');
      });
      
      // Select this option
      div.classList.add('selected');
      input.checked = true; // Make sure the radio button is checked programmatically

      // Enable the submit button
      const submitBtn = document.getElementById('surveySubmitBtn');
      if (submitBtn) submitBtn.disabled = false;
    });
    
    optionsContainer.appendChild(div);
  });
  
  // Ensure submit button state is reset correctly
  const submitBtn = document.getElementById('surveySubmitBtn');
  if (submitBtn) {
    submitBtn.disabled = true; // Disable until an option is chosen
    // Update button text
    if (state.currentSurveyQuestion < CONFIG.surveyQuestions.length - 1) {
      submitBtn.textContent = 'Next Question';
    } else {
      submitBtn.textContent = 'Continue'; // Last question in this block
    }
  }
}

// =================================================================
// =================================================================
// ===== REPLACE your existing surveySubmit function with this =====
// =================================================================
function surveySubmit() {
  const selectedOption = document.querySelector('input[name="likert"]:checked');
  
  if (!selectedOption) {
    alert('Please select an option.');
    return;
  }
  
  // --- START: CRITICAL FIX FOR DATA MIX-UP ---
  
  // 1. Get the global index of the *last* question they answered
  //    (e.g., if currentQuestionIndex is 2, they just finished questions 0 and 1. We look at index 1)
  //    Make sure currentQuestionIndex > 0 before accessing questionOrder
  if (state.currentQuestionIndex <= 0) {
      console.error("SurveySubmit called with invalid currentQuestionIndex:", state.currentQuestionIndex);
      // Decide how to handle this error, maybe go to debrief early?
      showPage('debrief');
      return;
  }
  const lastQuestionGlobalIndex = state.questionOrder[state.currentQuestionIndex - 1];
  if (lastQuestionGlobalIndex === undefined) {
      console.error("Could not determine last question index from order:", state.currentQuestionIndex - 1, state.questionOrder);
       // Decide how to handle this error
      showPage('debrief');
      return;
  }
  
  // 2. Look up what condition type (1, 2, or 3) that question belongs to
  const conditionType = CONFIG.conditions[lastQuestionGlobalIndex];
  if (conditionType === undefined) {
      console.error("Could not determine condition type for question index:", lastQuestionGlobalIndex);
      // Decide how to handle this error
      showPage('debrief');
      return;
  }
  
  // 3. Translate the type number into a clear name
  let conditionName = '';
  if (conditionType === 1) {
    conditionName = 'SRI'; // Self-View
  } else if (conditionType === 2) {
    conditionName = 'Avatar';
  } else if (conditionType === 3) {
    conditionName = 'Text';
  } else {
    console.error("Unknown condition type:", conditionType);
    conditionName = 'Unknown'; // Fallback name for safety, check CONFIG if this happens
  }
  
  // 4. Get the ID of the survey question (e.g., "anxiety")
  if (state.currentSurveyQuestion >= CONFIG.surveyQuestions.length) {
      console.error("Invalid current survey question index:", state.currentSurveyQuestion);
      // Decide how to handle this error
      showPage('debrief');
      return;
  }
  const questionId = CONFIG.surveyQuestions[state.currentSurveyQuestion].id;
  
  // 5. Create the correct, un-mixed key (e.g., "SRI_anxiety")
  const key = `${conditionName}_${questionId}`;
  
  // --- END: CRITICAL FIX ---
  
  // Store response using the new, correct key
  state.responses[key] = selectedOption.value;
  
  // --- Proceed as before ---
  state.currentSurveyQuestion++;
  
  if (state.currentSurveyQuestion < CONFIG.surveyQuestions.length) {
    displaySurveyQuestion(); // Show next survey question in the block
  } else if (state.currentQuestionIndex < 6) {
    showPage('interview'); // Move to next interview question (pair)
    showQuestion();
  } else {
    showPage('debrief'); // All questions and surveys done
    submitData();
  }
}
// =================================================================
// ================= END OF REPLACEMENT BLOCK ======================
// =================================================================

function submitData() {
  const data = {
    participantId: state.participantId,
    orderGroup: state.orderGroup,
    timestamp: new Date().toISOString(),
    ...state.responses, // Spread the collected responses
    redoCounts: state.redoCounts.join(',') // Join redo counts into a string
  };
  
  console.log('Study Complete. Submitting data:', data);
  
  const GOOGLE_SCRIPT_URL = 'https://script.google.com/macros/s/AKfycbxjv4KhOsOOxjplXLWYxQMYqg07FAVs_YdAY7yQNMO2TNV2p04GOOnK_izOZZkV93TD/exec'; // Make sure this URL is correct

  // Basic check for URL validity
  if (!GOOGLE_SCRIPT_URL || !GOOGLE_SCRIPT_URL.startsWith('https://script.google.com/')) {
      console.error("Invalid Google Script URL provided.");
      alert("Configuration error: Cannot submit data. Please contact the researcher.");
      return;
  }

  fetch(GOOGLE_SCRIPT_URL, {
    method: 'POST',
    mode: 'no-cors', // Added for potential cross-origin issues, though Apps Script usually handles simple POSTs
    body: JSON.stringify(data)
  })
  .then(response => {
      // Note: With no-cors, we cannot read the response content or status directly.
      // We can only detect network errors via .catch()
      // So, we assume success if fetch doesn't throw a network error.
      console.log('Data submission request sent successfully (no-cors). Check Google Sheet for confirmation.');
      // We can't check result.result === "success" here.
  })
  .catch(error => {
    // Catch network errors (e.g., offline, DNS issues, CORS blocking *before* the request if not 'no-cors')
    console.error('Network error during data submission:', error);
    alert("Could not submit your responses due to a network issue. Please check your connection or contact the researcher.");
  });
}


// Cleanup function attached to beforeunload event
window.addEventListener('beforeunload', (event) => {
  // Stop camera/mic stream
  if (state.stream) {
    state.stream.getTracks().forEach(track => track.stop());
    console.log("Media stream stopped.");
  }
  // Clear any active recording timer
  if (state.countdownInterval) {
    clearInterval(state.countdownInterval);
    state.countdownInterval = null;
    console.log("Countdown interval cleared.");
  }

  // Optionally, provide a warning if the user tries to leave mid-experiment
  // Check if the debrief page is currently hidden (meaning experiment not finished)
  if (pages.debrief && pages.debrief.classList.contains('hidden') && state.participantId) {
      // Standard way to show browser's default leave confirmation
      event.preventDefault(); // Required for Chrome
      event.returnValue = 'Are you sure you want to leave? Your progress may not be saved.'; // Standard message text
      return 'Are you sure you want to leave? Your progress may not be saved.'; // For older browsers
  }
});

</script>

</body>
</html>
